\chapter{Knihovna GEOC}
\label{5-geoc}

%\section{Tvorba knihovny GEOC} % mám to nechat zakomentované?
%\label{knihovna}

Algoritmy týkající se slučování vektorových map (\textit{conflation}) byly
implementovány v~externí knihovně \textit{GEOC} bez závislosti na~QGIS API. 
Zásuvný modul \textit{Conflate} umožňuje využití funkcionality knihovny 
v~Quantum GIS. Díky tomuto oddělení vznikla nezávislá knihovna, kterou bude
možné případně použít i~v~jiných programech a~projektech.

Tato kapitola popisuje jednotlivé algoritmy a~jejich implementaci v~knihovně
\textit{GEOC}, zároveň také stručně pojednává o~možnostech  jejich využití.
Podrobný popis jednotlivých tříd a~jejich metod je podrobněji popsán v~dokumentaci. % viz příloha

% úvodní poznámky, proč samost. knihovna (aby se to dalo využít i jinde než v mém pluginu)
% co popisuje kapitola, vyjmenování algoritmů, jakou funkcionalitu by měla zajišťovat (stručně)
\section{Reprezentace geometrie}
\label{reprezentace-geom}

Pro reprezentaci geometrie a~prostorové analýzy \textit{GEOC} využívá
knihovnu \textit{GEOS}. Geometrie prvků je představována třídou 
\texttt{geos::geom::Geometry}. Kromě samotné geometrie je v~algoritmech
často potřeba pracovat se~seznamem bodů jednoho či více prvků. V~těchto
případech je využita třída \texttt{geos::geom::CoordinateSequence}
a~\texttt{geos::geom::Coordinate}, která pak reprezentuje samostatný bod.


\section{Vertex Snapper} 
\label{vertexsnapper}

Při zpracování vrstev z~více zdrojů někdy stačí pouze upřesnit polohu či tvar 
prvků z~cílové vrstvy tak, aby se přiblížil prvkům z~vrstvy referenční. 
\mbox{Není-li} podrobnost obou datasetů příliš rozdílná, lze využít jednoduchého 
postupu \textbf{přichycení blízkých vrcholů}. % inspirace JCS

\subsection{Popis algoritmu}
\label{vs-algoritmus}

Nejjednodušším způsobem kombinace dvou vektorových vrstev je pouhé přichycení 
blízkých vrcholů cílové vrstvy k~vrstvě referenční. Obecný postup je následující:

\begin{enumerate}
 \item Na~počátku je třeba určit vzdálenostní toleranci, tedy maximální 
    vzdálenost mezi~dvěma body, kdy ještě bude provedeno jejich přichycení.
 \item Ke~každému prvku ze~zpracovávané vrstvy nalezneme nejbližší prvky 
    z~vrstvy referenční. To jsou prvky, jejichž nejkratší vzdálenost 
    od~zpracovávaného prvku není větší	než vzdálenostní tolerance.
 \item Pro~každý bod ze~zpracovávaného prvku vypočteme vzdálenosti ke~všem
    bodům z~blízkých referenčních prvků.
 \item Pokud nejmenší z~těchto délek je menší než vzdálenostní tolerance, 
    pak posuneme zpracovávaný bod do~odpovídajícího referenčního bodu s~touto
    nejmenší vzdáleností.
 \item Takto projdeme postupně všechny vrcholy všech prvků cílové vrstvy 
    a~snažíme se k~nim nalézt blízké body z~prvků vrstvy referenční. 
\end{enumerate}

% obrázek ilustrujici postup zpracovani
\label{vspic}
  \begin{figure}[h!]
    \centering
      %\includegraphics[width=300pt]{./pictures/vs-princip.pdf}
      \input{./pictures/vs-princip.pdf_tex}
      \caption{Postup přichycení vrcholů}
      \label{fig:vs-princip}
  \end{figure}

\subsection{Implementace} % text asi přepsat 
\label{vs-implementace}
% popis mé implementace algoritmu + zmínit třídy a funkce s odkazy na literaturu
Algoritmus pro~přichycení vrcholů upravované vrstvy k~referenční je 
implementován ve~třídách \texttt{Vertex\-Snapper} 
a~\texttt{Vertex\-Geometry\-Editor\-Operation}. Při~použití v~externí aplikaci 
stačí po~předání vstupních parametrů (k~tomu slouží metody 
\texttt{setRefGeometry()}, \texttt{setSubGeometry()} 
a~\texttt{setTolDistance()}) třídě \texttt{Vertex\-Snapper} zavolat funkci 
\texttt{snap()}. Ta vyhledá blízké prvky s~využitím prostorových indexů 
sestavených metodou \texttt{build\-Index()} třídy 
\texttt{Spatial\-Index\-Builder}.

Výsledky vyhledávání poté předá funkci \texttt{snap\-Vertices()}. Uvnitř této
metody se vytvoří instance  třídy \texttt{Vertex\-Geometry\-Editor\-Operation},
která edituje příslušnou geometrii přichycením blízkých vrcholů v~metodě
\texttt{edit()}. \texttt{Vertex\-Geometry\-Editor\-Operation} je potomkem třídy 
\texttt{geos::\-operation::\-Coordinate\-Operation}, která je \textit{inter\-face}
\footnote{rozhraní třídy, kde jsou deklarovány pouze abstraktní metody bez
implementace, není možné vytvořit instanci této třídy} třídou pro editaci 
geometrie.

Pro zjištění validity geometrií je volána metoda \texttt{isValid()} třídy
\texttt{geos::geom::\-Geometry}.

Výsledné geometrie lze získat zavoláním metody \texttt{getNewGeometry()},
která vrací vektor s~interní reprezentací geometrií.


\subsection{Využití}
\label{vs-vyuziti}

Přichycení bodů jedné vrstvy k~vrstvě druhé má své výhody i~nevýhody, které 
je před volbou tohoto způsobu zpracování třeba zvážit. Použití této metody 
je vhodné v~takových případech, kdy máme k~dispozici dvě vrstvy o~rozdílné 
přesnosti (tento rozdíl však nesmí být příliš veliký) a~prvky vzájemně se 
překrývající. Cílem je upřesnit polohu a~tvar prvků z~méně přesného datasetu. 
Dopředu je třeba si uvědomit, že kromě polohy prvků je měněn i~jejich tvar.

Využít by tento postup šel i~pro~přichycení dvou sousedních vrstev o~stejné 
přesnosti, avšak to znamená, že by se změnil pouze tvar krajních prvků 
(nedošlo by k~posunu celé vrstvy), a~to nemusí být vždy žádoucí. Jako jediný
z~algoritmů \textit{GEOC} má pak smysl pro~bodové vrstvy.

Pro~rozumné výsledky je důležité zvolit vhodnou toleranční vzdálenost. Tato 
hodnota by měla odpovídat maximální vzdálenosti, o~kterou se vrchol prvku 
může posunout. Při~volbě příliš krátké vzdálenosti se výsledná vrstva nemusí 
vůbec odlišovat od té vstupní. Naopak \mbox{je-li} zvolená vzdálenost delší 
než nejkratší úsek geometrie (linie, polygonu), může dojít k~přichycení dvou 
bodů k~jednomu bodu z~referenční vrstvy. Zda je toto přípustné či nikoli je 
už na~rozhodnutí uživatele.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  PRESUNUTO DO PROBLEMU
% \label{vsinvalid}
%   \begin{figure}[hbt]
%     \centering
%       \includegraphics[width=350pt]{./pictures/vs-invalid.pdf}
%       \caption{Vznik nevalidní geometrie při přichycení vrcholů}
%       \label{fig:vs-nevalidni}
%   \end{figure} 
% 
% V~některých případech může dojít ke~vzniku nevalidních geometrií, to je takových,
% jejichž segmenty se vzájemně protínají apod. To se nejčastěji stává u~protáhlých 
% úzkých prvků a~jiných speciálních tvarů. Příkladem může být situace uvedená 
% na~obrázku \ref{fig:vs-nevalidni}, kde růžový polygon je prvkem přichycen 
% k~referenční fialové vrstvě, ale z~důvodu nedostatečné hustoty vrcholů a~nevhodného
% tvaru vzniká nežádoucí křížení. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Někdy může být tento postup výhodný i~v~případě, kdy chceme odstranit drobné mezery či 
%překryty v~rámci jedné vrstvy. Poté stačí nastavit danou vrstvu jako referenční i~jako
%cílovou.  -- teď to ale nejde, protože se z mezer stanou překryty apod. (vrstva se v 
%průběhu nemění), ale šlo by to asi dodělat. 


\section{Coverage Alignment} 
\label{coverage alignment}

\textit{Coverage alignment} lze vysvětlit jako \textbf{zarovnání jedné vrstvy 
k~vrstvě druhé}. Tento způsob je složitější než výše uvedené přichytávání vrcholů.
V~knihovně \textit{GEOC} je využit opět pro~úpravu jedné vrstvy na~základě vrstvy 
referenční. Do~upravované vrstvy nejsou žádné prvky přidávány ani z~ní vymazávány,
pouze jde o~jejich modifikaci. Velmi podobný algoritmus se však dá použít 
i~ke~kombinaci dvou vrstev. % inspirace Saalfeld

\subsection{Popis algoritmu}
\label{ca-algoritmus}

Nejčastější používaný postup při~spojování vektorových map je následující.

\begin{enumerate}
 \item Nejprve je třeba nalézt odpovídající si prvky v~obou překrývajících se 
    vrstvách. Kritéria pro~určení odpovídajících si prvků mohou být velmi 
    odlišná. Existuje mnoho algoritmů řešících tuto problematiku, přičemž 
    postupy se mohou různit podle toho, zda je úkolem vyhledání 
    odpovídajících si bodů, polygonů či linií. Kritéria a~postup použitý 
    v~knihovně \textit{GEOC} je popsán níže.
 \item Poté, co se určí odpovídající si prvky, musí se určit totožné vrcholy 
    těchto dvojic prvků. Ty z~vrcholů, které jsou určeny s~dostatečnou 
    přesností (ta může být určena například danou vzdálenostní tolerancí), 
    jsou označeny jako body budoucí triangulační sítě.
 \item Jak už bylo naznačeno, z~nalezených bodů se vytvoří pomocí Delaunayho 
    triangulace\footnote{Delaunayho triangulace z~množiny bodů v~rovině vytvoří takovou 
    trojúhelníkovou síť, pro kterou platí, že v~kružnici opsané každému
    trojúhelníku, neleží žádný jiný bod. DT maximalizuje
    minimální úhly trojúhelníků.} trojúhelníková síť. 
    %ML: doplnit poznamku pod carou - kratka charakteristka DT .. doplneno
 \item Následně se provede lokální, nejčastěji afinní transformace v~každém 
    trojúhelníku sítě. Tak se přetransformují body cílové vrstvy do~systému 
    vrstvy referenční.
 \item Celý postup je možné iterativně opakovat, dokud nedosáhneme 
    požadovaného výsledku (ten může být dán např. podmínkou minimálního 
    množství nalezených odpovídajících si vrcholů či prvků).
\end{enumerate}

% obrázek ilustrujici postup zpracovani, vč. tinu apod.
\label{capic}
  \begin{figure}[H]
    \centering
      \def\svgwidth{400pt}
      \input{./pictures/ca-princip.pdf_tex}
      %\includegraphics[width=350pt]{./pictures/ca-princip.pdf}
      \caption{Postup zarovnání vrstev}
      \label{fig:ca-princip}
  \end{figure}

V~knihovně \textit{GEOC} je pro nalezení odpovídajících si prvků využito 
obdobného postupu jako ve~výše zmiňované knihovně \textit{JCS}. Využívá 
se vrcholová Hausdorffova vzdálenost, přičemž tato vzdálenost není počítána 
přímo. Splnění podmínky, že dané prvky nejsou od~sebe dále, než je daná 
Hausdorffova vzdálenost, se testuje pomocí obalových zón jednotlivých prvků 
následujícím způsobem.

\begin{enumerate}
 \item Máme dva prvky A a~B ze~dvou různých překrývajících se vrstev.
 \item Pokud prvek B leží v~obalové zóně prvku A o~velikosti vzdálenostní 
    tolerance a~A leží v~obalové zóně prvku B o~stejné velikosti, je možné, 
    že si prvky odpovídají a~pokračuje se dalším krokem. Situace je naznačena
    na~obrázku \ref{fig:buffer}. V~opačném případě si prvky neodpovídají.

\label{bfpic}
  \begin{figure}[H]
    \centering
      \small
      \def\svgwidth{400pt}
      \input{./pictures/buffer-test.pdf_tex}
      %\includegraphics[width=300pt]{./pictures/buffer-test.pdf}
      \caption{Porovnání prvků na základě jejich obalových zón}
      \label{fig:buffer}

  \end{figure}
 \item Dále se testuje, zda hranice prvku B leží v~obalové zóně hranice prvku
    A a~naopak (viz obrázek \ref{fig:buffer-boundary}). Je-li splněna i~tato 
    podmínka, pak jsou prvky označeny za~odpovídající si.

\label{bf2pic}
  \begin{figure}[H]
    \centering
      \small
      \def\svgwidth{400pt}
      \input{./pictures/buffer-boundary.pdf_tex}
      %\includegraphics[width=300pt]{./pictures/buffer-boundary.pdf}
      \caption{Porovnání prvků na základě obalových zón jejich hranic}
      \label{fig:buffer-boundary}
  \end{figure}

\end{enumerate}

%% ML: doplnit ilustraci .. obrázek obal. zón

\subsection{Implementace}
\label{ca-implementace}
Algoritmus je opět implementován pod jedinou metodou \texttt{align()} 
třídy \texttt{Coverage\-Alignment}, kterou je možné zavolat po~nastavení
základních parametrů. Ta postupně volá metody provádějící jednotlivé
kroky algoritmu.

Nejdříve je třeba nalézt odpovídající si prvky. K~tomu slouží třída 
\texttt{Matching\-Geometry}, která k~dané geometrii najde odpovídající
(\texttt{set\-Match()}). Obdobně jako u~\texttt{Vertex\-Snapper} je i~zde 
při hledání blízkých prvků využíváno prostorových indexů, které jsou 
vytvořeny metodou \texttt{SpatialndexBuilder::build\-Index()}. Testy
obalových zón jsou prováděny za~pomoci prostorových funkcí 
\texttt{buffer()}, která vytvoří obalovou zónu, \texttt{getBoundary()},
která vrací hranici geometrie, a~konečně \texttt{contains()}, která
testuje, zda jedna geometrie obsahuje druhou. Všechny jsou přitom
metodami \texttt{geos::geom::Geometry}.

Určení blízkých bodů je pak provedeno prostřednictvím metody 
\texttt{choose\-Matching\-Points()}, která dále využívá
\texttt{find\-Closest\-Points()} a~\texttt{clean\-Matching\-Points()} 
třídy \texttt{Coverage\-Alignment}.

Třetím krokem je vytvoření trojúhelníkové sítě metodou
\texttt{create\-TIN()}, která k~tomu využívá třídu 
\texttt{Tri\-an\-gu\-la\-tion}.  Ta pouze aplikuje třídu 
\texttt{geos::triangu\-late::Delaunay\-Triangulation\-Builder}, kde je 
vytvářen \zk{TIN} ze~zadaných bodů.

Konečně je provedena postupně transformace všech prvků. Funkce pro
transformaci poskytuje třída \texttt{Affine\-Trans\-for\-mation},
která transformuje prvky na~základě předané geometrie a~triangulační
sítě. Ta je volána prostřednictvím třídy pro editaci 
\texttt{Align\-Geo\-metry\-Edi\-tor\-Ope\-ra\-tion}.


\subsection{Využití}
\label{ca-vyuziti}

Na~rozdíl od~předchozího algoritmu je tento trochu šířeji využitelný. Je opět 
vhodný pro~zpřesnění vrstvy dle vrstvy referenční, avšak tentokrát nejsou 
pouze přichytávány blízké vrcholy, ale jsou upravovány téměř všechny vrcholy. 
To zajišťuje reálnější výsledky i~v situacích, kdy hustota vrcholů v~obou 
datasetech je velmi rozdílná.

% poznámka o výhodách a nevýhodách využití u liniových a polygon. datech


\section{LineMatcher}
\label{line matcher}

Častým předmětem spojování vektorových dat jsou liniové mapy silnic, cest apod.
Proto byl do~knihovny doplněn i~algoritmus \textit{Line Matcher}, který je
určen speciálně pro liniové vrstvy. Výrazný rozdíl oproti předchozím algoritmům
je také fakt, že tento nezarovnává jednu vrstvu ke~druhé, ale výsledkem je
průměr z~odpovídajících si prvků obou vrstev. Nezáleží tedy na~tom, která 
z~vrstev je referenční. Prvky se zde nemyslí celé linie, ale pouze jejich
segmenty.

\subsection{Popis algoritmu}
\label{lm-algoritmus}

Jak je uvedeno výše, tento algoritmus pracuje pouze se~segmenty jednotlivých
linií, a~to z~toho důvodu, že jedna dlouhá linie, může být v~jiném datasetu
rozdělena na~několik menších například přerušením na~křižovatkách. Pro každou
linii jednoho datasetu je pak provedeno následující. 

\begin{enumerate}
 \item Ke~každému segmentu linie jsou nalezeny blízké linie z~druhého datasetu.
       Stejně jako u~předchozích, i~zde je blízkost definována zvolenou toleranční
       vzdáleností.
 \item Testovaný segment je dále porovnáván s~každým segmentem z~těchto blízkých
       linií na~základě kritérií \ref{crit} uvedených níže.
 \item Pokud je splněna předem zvolená hodnota podobnosti segmentů pro všechna 
       kritéria $s_1,s_2,s_3$ je jako výsledná podobnost určena hodnota $s$.
 \item Z~opovídajících segmentů je nalezen takový, jehož podobnost s~testovaným
       je největší.
 \item Výsledný segment je průměrem ze~dvou nejlépe si odpovídajících segmentů.
\end{enumerate}

\subsubsection*{Kritéria pro určení odpovídajících si liniových segmentů}
První dvě kritéria dle [odkaz na literaturu] nejlépe určují podobnost dvou % odkaz na lit. arcgis report
linií. Třetí kritérium bylo přidáno pro praktické použití tak, aby se neurčovaly
pouze podobné prvky, ale i~prvky blízké. %Ve~výsledku mu pak byla přiřazena největší 
% váha, jelikož při této úloze je blízkost segmentů důležitá.
Jednotlivá kritéria určující podobnost mohou nabývat hodnot od~$0$ do~$1$,
kde $1$ znamená naprostou shodu.

\begin{equation}
 \begin{aligned}
 s_1 = \frac{ \Delta l_{max} - \Delta l }{ \Delta l_{max} - \Delta l_{min}},\ 
 s_2 &= \frac{ \alpha_{max} - \alpha }{ \alpha_{max} - \alpha_{min}},\ 
 s_3 = \frac{ d_{max} - d }{ d_{max} - d_{min}}\\
 s &= \frac{s_1+s_2+s_3}{3}
 \label{crit}
 \end{aligned}
\end{equation}

Hodnoty $\Delta l_{max}$, $\Delta l_{min}$ udávají maximální a~minimální rozdíl délek
segmentů v~celém datasetu, $\Delta l$ je pak rozdíl délek porovnávaných segmentů.
$\alpha$ udává odchylku dvou segmentů. Hodnota $\alpha_{max}$ ve většině případů může
být zvolena $90^{\circ}$, $\alpha_{min}$ pak $0^\circ$. Proměnná $d$ ve~třetím 
kritériu reprezentuje vzdálenost segmentů, která je spočtena jako průměr vzdáleností
jejich počátečních a~koncových bodů. Jelikož se porovnávají pouze blízké segmenty,
$d_{max}$ je rovno toleranční vzdálenosti, $d_{min}$ by pak mělo odpovídat nejmenší
vzdálenosti krajních bodů dvojice segmentů z~obou datasetů.


\subsection{Implementace}
\label{lm-implementace}

Veškeré funkce pro tento algoritmus jsou obsaženy ve~třídě \texttt{Line\-Matcher}.

Funkce \texttt{match()} hledá postupně ke~každé linii blízké linie z~druhého datasetu.
Následně předá výsledky tohoto hledání metodě \texttt{match\-Line()}, která ke~každému
segmentu linie, nalezne prostřednictvím metody \texttt{matching\-Segment()} odpovídající
segment mezi předanými blízkými prvky. Pokud k~nějakému úseku linie není určen
žádný dostatečně podobný, je zde linie přerušena. Z~původního jednoduchého liniového
prvku tak může vzniknout multiprvek. Pro vytváření nových geometrií jsou využívány
metody \texttt{createLineString()} a~\texttt{createMultiLineString()} třídy 
\texttt{geos::geom::GeometryFactory} knihovny \textit{GEOS}.
 

Výpočet kritérií podobnosti segmentů se nachází v~metodě \texttt{similarity()}. 

\subsection{Využití}
\label{lm-vyuziti}

\texttt{LineMatcher} lze využít pro spojování liniových vrstev. Map různých cest, 
silnic, tras atd. existuje velké množství i~díky rozvoji technologií \zk{GNSS}. 
Právě k~jejich slučování slouží \texttt{LineMatcher}. Hodí se i~pro vyhledání 
společných prvků obsažených ve~dvou datasetech. Příkladem aplikace takové je 
určení cyklotras vedoucích po~silnici z~vrstvy silnic a~cyklotras.  % trasy z GPS je třeba upravit -> menší hustota bodů apod.

Vzhledem k~požadavku co nejobecnějšího využití je výsledkem tohoto algoritmu
průměr z~odpovídajících si prvků.  Někdy by však bylo vhodnější nechat prvkům
původní polohu, pouze vymazat ty nepasující. Naopak může být požadavkem také
ponechání i neodpovídajících si prvků apod. Různýmí drobnými modifikacemi
by se tedy dalo dosáhnout lepšího využití pro nějaký konkrétní případ.
