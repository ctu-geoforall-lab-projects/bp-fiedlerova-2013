\chapter{Problémy a jejich řešení}
\label{7-problemy}

\section{Použití knihovny GEOS}
\label{problemy-geos}
Jako poměrně zásadní problém se ukázalo použití knihovny \zk{GEOS}. 
Přestože tato knihovna je napsána v~jazyku C++, obsahuje \textit{wrapper} 
v~podobě C~API. Hlavním důvodem toho je zajištění vyšší 
stability. Při~použití C~API totiž není nutné vlastní aplikaci,
která ho používá, při~každé změně v~knihovně \zk{GEOS} překompilovat. 
Proto většina programů využívajících \zk{GEOS} a~mezi nimi i~Quantum 
GIS používají právě C~API. Nicméně to má i~své nevýhody. V~C~API bohužel 
zatím není implementována veškerá funkcionalita C++~API. Některé chybějící 
funkce lze obejít aplikací sice složitějšího postupu, nicméně výsledek je 
obdobný jako při~použití C++~API. Avšak jiná funkcionalita je pro~uživatele 
C~API zcela nedostupná. Po~dlouhých úvahách\footnote{O~problému jsem napsala
na~\textit{mailing-list} vývojářů \textit{GEOSu} a~odpovědí bylo uvedení 
již zmíněných pro a~proti. Problém jsem následně prodiskutovala s~vedoucím 
práce, který mi doporučil toto řešení.} bylo proto v~knihovně \zk{GEOC} 
přistoupeno k~využití C++~API i~s~rizikem, že bude při~každé změně nutné 
vše překompilovat. 

S~tím souvisí i~další problém převodu geometrie. Jelikož v~programu \zk{QGIS} 
je používáno právě C~API, nelze \zk{GEOS} geometrii jednoduše převést na~typ 
\zk{QGIS} geometrie. Tento problém byl vyřešen konverzí mezi těmito dvěma
typy přes \zk{WKT}. Nevýhoda tohoto postupu je však zpomalení běhu programu 
obzvláště u~rozsáhlejších datasetů. Toto by mělo být v~budoucnu vyřešeno 
vytvořením vlastního C~API.


\section{Rychlost zpracování}
\label{problemy-rychlost}

\subsubsection{Vyhledání blízkých prvků}

Základem použitých algoritmů je vždy nalezení blízkých či podobných prvků 
ze~dvou vrstev. Pro~nalezení takových dvojic prvků je obecně třeba porovnat 
každý prvek z~jedné vrstvy s~každým prvkem z~vrstvy druhé. Je tedy třeba 
porovnat $n\cdot m$ dvojic, kde $n$ je počet prvků vrstvy první a~$m$ vrstvy 
druhé. U~rozsáhlejších datasetů je tedy nutné provést poměrně velké množství 
operací a~čas zpracování pak výrazně roste. Tento problém byl částečně vyřešen 
aplikací prostorových indexů\footnote{prostorové indexy jsou využívány pro 
optimalizaci prostorových dotazů v~prostorových databázích}. Konkrétně byla 
využita třída \texttt{geos::index::strtree::STRtree} knihovny \zk{GEOS} .
Tato třída implementuje metodu indexování dat založenou na~\textit{R-Tree}
\footnote{česky R-strom, prostorová stromová datová struktura využívající 
minimální ohraničující obdélníky}. Díky tomu se porovnávají pouze dvojice prvků, 
u~nichž to má smysl, tedy takové, jejichž minimální ohraničující obdélníky 
(v~některých algoritmech rozšířené o~toleranční vzdálenost) se protínají. 

Použití prostorových indexů rychlost zpracování sice značně zvýšilo (viz 
kapitola \ref{problemy-test}), ale stále trvá zpracování rozsáhlejších dat 
obzvláště u~algoritmu \linebreak[5] \texttt{Coverage\-Alignment} poměrně 
dlouhou dobu. Zvýšení rychlosti by bylo možné dosáhnout použitím prostorových 
indexů nejen při vyhledávání blízkých prvků, ale i~při následném hledání 
blízkých bodů. V~těchto případech nebyly prostorové indexy využity z~toho 
důvodu, že pro reprezentaci bodů je v~algoritmech použita třída 
\texttt{geos::geom::Coordinate}, pro níž však nejsou na~rozdíl 
od~\texttt{geos::geom::Geometry} prostorové indexy v~knihovně \zk{GEOS} 
implementovány.


\subsubsection{Testování podobných prvků}

Další částí programu, která působí výrazné zpomalení, je vyhledávání
odpovídajících si geometrií ve~třídě \texttt{MatchingGeometry}. Konkrétně
se jedná o~test, kdy jsou porovnávány obalové zóny prvků. Konstrukce
obalových zón je výpočetně náročná, proto je žádoucí, aby se tento test
prováděl u~co nejmenšího počtu prvků. V~algoritmu je tento počet snížen
porovnáváním pouze blízkých prvků. Také by bylo možné u~těchto 
blízkých prvků nejdříve např. testovat vzdálenost centroidů, porovnávat
jejich plochu či délku. Tento postup by však nemusel vždy čas běhu programu
zrychlit. Pro rozhodnutí, zda ho použít, by bylo nezbytné znát charakteristiku
zpracovávaných dat.


\subsection{Porovnání rychlosti s a bez použití prostorových indexů}
\label{problemy-test}
Porovnání rychlosti bylo provedeno nad dvojicí polygonových vrstev\linebreak[5] 
\texttt{vyber\_CR} a~\texttt{vyber\_obce}, které obsahují polygony obcí části 
ČR, a~nad dvojicí li\-niových vrstev \texttt{zel1} a~\texttt{zel2} obsahující 
výběr železnic ve~Středočeském kraji. Použity byly pouze tyto výběry, nikoliv 
data z~celé České republiky, jelikož na~tak velkých datasetech zpracování 
bez prostorových indexů může trvat poměrně dlouho.

Testovány byly vždy uvedené dvojice datasetů pro různé toleranční vzdálenosti,
a~to při zpracování algoritmy \texttt{Vertex\-Snapper} a~\texttt{Coverage\-Alignment}
s~použitím prostorových indexů a~bez jejich použití. Kompletní výsledky testování 
jsou uvedeny v~tabulkách v~příloze \ref{priloha-testovani}. Zde uvádím jen přehled 
výsledků testování.

\begin{table}[H]
 \centering
  \caption[Výsledky testování]{Výsledky testování - zrychlení algoritmů 
	  při použití prostorových indexů}
\begin{tabular}{|c|cc|cc|}
\hline
  & \multicolumn{2}{|c}{VertexSnapper} & \multicolumn{2}{|c|}{CoverageAlignment} \\
 toleranční vzálenost & 100 m & 1000 m & 100/1000 m & 10 000 m \\
\hline
\hline
 polygonová data & 20.9 $\rightarrow$ 0.8 s& 22.6 $\rightarrow$ 0.7 s& 
 4.7 $\rightarrow$ 0.5 s& 4.9 $\rightarrow$ 0.5 s\\
 liniová data & 38.4 $\rightarrow$ 1.1 s& 39.0 $\rightarrow$ 1.8 s& 
 10.5 $\rightarrow$ 0.7 s& 10.5 $\rightarrow$ 4.2 s\\
\hline
\end{tabular}
  \label{tab:vysledky}
\end{table}


Z~dat uvedených v~tabulce \ref{tab:vysledky} je patrné, že doplnění 
prostorových indexů oba algoritmy výrazně urychlilo (řádově více než 
desetkrát). Pro podrobnější rozbor a~určení míry zrychlení by 
samozřejmě nutné provést mnohem rozsáhlejší testování. Zde bylo účelem 
pouze ukázat, že prostorové indexy algoritmy opravdu zrychlily.

U~algoritmu \texttt{Coverage\-Alignment} je navíc patrné,
že při použití prostorových indexů závisí rychlost nejen
na~vstupních datech, ale také na~nastavení toleranční 
vzdálenosti. % To je dáno tím, ...
%stejný (pokaždé procházíme vše), s indexy se liší  - jen u align, proč ne u vs????

\section{VertexSnapper}
\label{problemy-vs}

\subsubsection{Nevalidní geometrie}
Vzhledem k~principu tohoto algoritmu mohou při jeho použití vznikat nevalidní 
geometrie, to je takové, jejichž segmenty se vzájemně protínají apod. 
To se nejčastěji stává u~protáhlých úzkých prvků a~jiných speciálních tvarů. 
Příkladem může být situace uvedená na~obrázku \ref{fig:vs-nevalidni}, 
kde žlutý polygon je prvkem přichycen k~referenční modré vrstvě, 
ale z~důvodu nedostatečné hustoty vrcholů a~nevhodného tvaru vzniká nežádoucí 
křížení.

\label{vsinvalid}
  \begin{figure}[hbt]
    \centering
      \input{./pictures/vs-invalid.pdf_tex}
      \caption{Vznik nevalidní geometrie při přichycení vrcholů}
      \label{fig:vs-nevalidni}
  \end{figure} 

Tyto chyby je samozřejmě možné opravit ručně po~zpracování. Avšak
v~rozsáhlých datasetech může být nevalidních prvků poměrně velké množství.
Pokud se toto nestalo z~důvodu nevhodného nastavení zpracování, bylo by 
vhodné, aby samotný algoritmus tyto chyby minimalizoval. To by bylo možné 
například přidáním nových vrcholů na~vhodná místa (dlouhé segmenty bez vrcholu
apod.). Další možností je zrušit přichycení vrcholu, pokud při něm vznikne
nevalidní geometrie. Nevýhoda takového postupu je horší zarovnání výsledné 
vrstvy. 

\subsubsection{Přichycení do jednoho bodu}
Speciálním případem vzniku nevalidní geometrie je situace, kdy se všechny 
vrcholy prvku přichytí pouze k~jednomu bodu. Tím vzniká z~linie či polygonu
bodový prvek. K~této situaci dochází v případě volby velké toleranční 
vzdálenosti v~poměru k~velikosti prvku. U~datasetů obsahujících prvky
o~výrazně rozdílných velikostech se tomu nelze vždy vyhnout. V~knihovně
\zk{GEOC} tento problém zatím není vyřešen. Nejjednodušší řešení, které
by bylo možné implementovat je nabídnout uživateli, co s~takovými prvky provést.
Na~výběr by byly tyto možnosti:
\begin{itemize}
 \item odstranění takových prvků,
 \item export těchto prvků do nové vrstvy, kde by bylo možné je dále upravovat,
 \item ponechání původní geometrie. 
\end{itemize}


\section{MatchingGeometry}
\label{problemy-mg}

Algoritmus \texttt{MatchingGeometry} vyhledává odpovídající si geometrie tak,
že nejdříve nalezne blízké prvky k~dané geometrii a~pak testuje postupně všechny
tyto blízké prvky. Po nalezení prvního odpovídajícího prvku se už další prvky
netestují. To může způsobit, že je nalezen sice odpovídající prvek, avšak
nemusí to být ten, který je danému prvku podobný nejvíce. U~polygonových vrstev
při vhodné volbě toleranční vzdálenosti tento problém většinou nenastává, 
ale u~vrstev liniových se může objevit poměrně často. 

Řešením by bylo seřadit před testováním blízké prvky dle nějakého
kritéria, které by určovalo pravděpodobnost, že si budou odpovídat. Takové
kritérium je však obtížné určit. U~polygonů by to mohla být velikost plochy,
kde se polygony nepřekrývají. Jak už bylo řečeno, nastává tento problém
spíše u~vrstev liniových, a~proto by takové kritérium příliš nepomohlo.
%Nejvhodnější by proto bylo použít pro liniové vrstvy zcela odlišný algoritmus.

% jeden prvek odpovídající dvěma

Výše uvedeným problémům u~liniových vrstev se lze vyhnout použitím jiného
algoritmu \textit{RoadMatcher/LineMatcher}, který porovnává pouze jednotlivé
úseky linií, nikoli celé prvky. 
% obrázek kritéria pro polygony   
% obrázek u linií

\section{CoverageAlignment}
\label{problemy-ca}

\subsubsection{Vytvoření trojúhelníkové sítě}
Po~nalezení odpovídajících si prvků je nutné určit vrcholy triangulační sítě.
V~použitém algoritmu jsou zvoleny dvojice blízkých vrcholů dvou odpovídajících
si prvků. Důsledkem tohoto výběru může být nepravidelné rozložení vrcholů sítě
a~také vytvoření troj\-úhelníkové sítě pouze nad~malou částí území, a~tudíž 
nezahrnující všechny odpovídající si prvky.
% obrázek tinu bez rohů a s rohy, kdy je výhodný

Pro pokrytí větší části území byly proto zahrnuty do~vrcholů rohové body, jejichž
souřadnice odpovídají extrémním souřadnicím ze~všech vrcholů prvků zpracovávané 
vrstvy, ke~kterým byl nalezen ekvivalent ve~vrstvě referenční. Tyto body mají 
v~obou systémech pro~transformaci totožné souřadnice. Tímto postupem se nejen 
zajistí zpracování všech odpovídajících si prvků, ale také zarovnání prvků 
i~v~případech, kdy se jako odpovídající určí pouze jeden či dva body, z~nichž 
by bez této úpravy nebylo možné \zk{TIN} sestrojit. Nevýhodou zvoleného řešení jsou 
nevhodné tvary trojúhelníků na okrajích sítě a~tím způsobené méně přesné zarovnání 
v~těchto oblastech. Avšak i~přes tyto nevýhody jsou výsledky zarovnání datasetů 
s~použitím rohových bodů přesnější. 
% obrázek, kdy rohy mohou způsobit problémy

Vylepšením tohoto řešení by mohlo být použití bodů konvexní obálky pasujících
prvků namísto pouze čtyř rohových bodů.
% zjednodušení TINu -> odkaz na http://mapcontext.com/autocarto/proceedings/auto-carto-8/pdf/pages641-650.pdf

Velký vliv na~tvar \zk{TIN} má způsob volby blízkých bodů. V~některých programech
(např. ArcGIS) je proto tento krok přenechán uživateli. Počet dvojic bodů je
sice obecně nižší, avšak jsou tak zvoleny pouze skutečně si odpovídající body
a~jejich rozložení je většinou pravidelné. Výsledek je pak blíže skutečnosti
než automatické zpracování. Navíc bylo experimentálně zjištěno, že větší počet
trojúhelníků nezajistí větší přesnost, a~obecně tak postačí jedna dvojice
bodů pro padesát prvků. % odkaz http://mapcontext.com/autocarto/proceedings/auto-carto-8/pdf/pages641-650.pdf nebo přímo Saalfeld

\subsubsection{Nevalidní geometrie}

V~případě nevhodné konfigurace odpovídajících si trojúhelníků může v~důsledku
lokální transformace dojít ke~vzniku nevalidních geometrií. Této situaci by se
dalo předejít výpočtem jednoho transformačního klíče ze~všech blízkých bodů
vyrovnáním a~aplikací globální transformace. Tak by nevznikly neplatné geometrie,
ale snížila by se přesnost zpracování, až na~situace, kdy by mezi datasety byl
téměř konstantní posun, natočení a~změna měřítka u~všech prvků.

% doplnit obrázek

Tento problém úzce souvisí s~volbou toleranční vzdálenosti. Při dodržení pravidla
o~nejkratším segmentu  se mu lze téměř vyhnout (stále mohou vznikat nevalidní 
geometrie u~příliš úzkých, protáhlých tvarů apod.). 

%Pravděpodobně by bylo možné nevalidní geometrie automaticky opravit např. výměnou
%vrcholů způsobujících křížení hran. Nyní je oprava těchto geometrií ponechána 
%na~uživateli.

\subsubsection{Volba počtu iterací}

V~popisu algoritmu zmiňuji, že proces zarovnání může probíhat iterativně.
Otázkou je volba počtu iterací. Nabízí se tři možnosti.
\begin{enumerate}
 \item konstantní počet iterací
 \item ponechání volby počtu iterací na uživateli
 \item opakování procesu tak dlouho, dokud není splněna určitá podmínka
\end{enumerate}
Pevně daný počet není příliš vhodný, jelikož vůbec nezohledňuje výsledky
předchozí iterace. Vzhledem k~tomu, že běžný uživatel by pravděpodobně
obtížně určil vhodný počet iterací, zůstává třetí možnost. Tím vyvstává
problém zvolení vhodné podmínky. Může to být počet nových odpovídajících 
si prvků, počet nově nalezených dvojic bodů, počet zpracovaných prvků aj.
Dle [..]  obvykle postačí dvě až tři opakování, % odkaz na [Saalfeld] 
přičemž mezi jednotlivými cykly je vhodná kontrola operátora,
který by měl odstranit případné hrubé chyby. Zároveň navrhuje jako podmínku
počet nově nalezených odpovídajících si prvků. Cyklus se tedy opakuje,
dokud jsou nacházeny nové dvojice pasujících prvků. Tento postup je   % zatím ještě ne
v~knihovně \zk{GEOC} implementován bez možnosti kontroly mezi iteracemi. 


\section{Line Matcher}
\label{problemy-lm}

\subsubsection*{Navázání linií}
Při určování podobných segmentů v~rámci jedné linie nastává problém jejich
navázání. V~závislosti na~nastavení funkce mohou při napojení výsledných
segmentů vznikat na~linii nežádoucí \uv{zuby} (viz obrázek \ref{fig:toothpic}). % viz obrázek
Tento problém v~algoritmu nebyl vyřešen, jelikož nelze jednoduše rozhodnout, 
kdy se jedná o~nesprávný tvar linie a~kdy je výsledek takto korektní.
Aby nevznikaly pouze samostatné nenavazující segmenty, byly i~přes toto
riziko napojovány.

\label{toothpic}
  \begin{figure}[hbt]
    \centering
      \input{./pictures/tooth.pdf_tex}
      %\includegraphics[width=300pt]{./pictures/tooth.pdf}
      \caption{Příklad situace, kdy vzniká \uv{zub}}
      \label{fig:toothpic}
  \end{figure}

\section{Automatická oprava nevalidních geometrií}
\label{problemy-opravy}

Jak již bylo uvedeno výše, častým problémem u~všech algoritmů je vznik
nevalidních prvků. Proto byla do knihovny \zk{GEOC} přidána třída
\texttt{Geometry\-Correction\-Operation}, kterou lze pro dodatečnou 
opravu nově vzniklých geometrií použít. Ne vždy je však jednoduché 
rozhodnout, jak geometrii změnit, aby výsledek odpovídal skutečnosti. 
V~programu proto byla aplikována jedna možnost způsobu opravy 
a~na~uživateli ponecháno rozhodnutí, zda automatickou korekci využít.

Automaticky je možné opravit tyto dvě chyby v~geometrii:

\begin{itemize}
 \item Křížení segmentů
	\subitem Změněna orientace hrany či hran mezi křížícími se úseky.
% obrázek
\label{crospic}
  \begin{figure}[hbt]
    \centering
      \input{./pictures/crossing.pdf_tex}
      %\includegraphics[width=300pt]{./pictures/crossing.pdf}
      \caption{Oprava křížících se segmentů}
      \label{fig:crossing}
  \end{figure}

 \item Slepé větve
	\subitem Vyřešeno odstraněním bodu na~konci větve.

\label{deadpic}
  \begin{figure}[hbt]
    \centering
      \input{./pictures/dead-branch.pdf_tex}
      %\includegraphics[width=300pt]{./pictures/dead-branch.pdf}
      \caption{Oprava slepých větví}
      \label{fig:dead-branch}
  \end{figure}
% obrázek
\end{itemize}

Samozřejmě existuje více možností, jak výše uvedené chyby opravit.
U~křížících se polygonů se často používá také pouhé přidání vrcholů
do~místa průsečíku segmentů. Tím vznikne validní geometrie a~nezmění
se přitom její tvar. Vzhledem k~tomu, že u~úprav prováděných 
s~polygony při slučování map, vznikají křížením většinou spíše drobné
\uv{výstupky}, je použité řešení přijatelné. Navíc funkci pro opravu
geometrií přidáním bodů obsahuje většina \zk{GIS} programů, takže není
pro uživatele složité ji po~spojení dat v~rámci \textit{postprocessingu}
aplikovat. Stejně tak se ručně musí opravit další chyby jako je 
otvor v~polygonu dotýkající se vnějšího okraje atd.
